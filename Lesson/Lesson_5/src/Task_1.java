// Обзор функционала Map
// ****************************

// Обзор функционала Map

// Интерфейс Map<K, V> представляет отображение или иначе говоря словарь, где каждый элемент представляет пару "ключ-значение".
// При этом !!!все ключи уникальные!!! в рамках объекта Map. Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта.

// “Ключ” назвали ключом не просто так. Доступ к значениям в HashMap осуществляется по ключу
// (но никак не наоборот — ключ нельзя получить по значению,
// ведь значения могут быть повторяющимися).

// Ключевые особенности:
//● допускаются только уникальные ключи, значения могут повторяться;
//● помните про null значения*;
//● ускоренная обработка данных;
//● порядок добавления не запоминается.

// Базовым классом для всех отображений является абстрактный класс AbstractMap,
// который реализует большую часть методов интерфейса Map. Наиболее распространенным классом
// отображений является HashMap, который реализует интерфейс Map и наследуется от класса
// AbstractMap.

//Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс Map НЕ расширяет интерфейс Collection.
//Среди методов интерфейса Map можно выделить следующие:
//•	void clear(): очищает коллекцию
//•	boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
//•	boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
//•	Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
//•	boolean equals(Object obj): возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
//•	boolean isEmpty: возвращает true, если коллекция пуста
//•	V get(Object k): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
//•	V getOrDefault(Object k, V defaultValue): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение defaultVlue
//•	V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
//•	V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
//•	Set<K> keySet(): возвращает набор всех ключей отображения
//•	Collection<V> values(): возвращает набор всех значений отображения
//•	void putAll(Map<? extends K, ? extends V> map): добавляет в коллекцию все объекты из отображения map
//•	V remove(Object k): удаляет объект с ключом k
//•	int size(): возвращает количество элементов коллекции

//Чтобы положить объект в коллекцию, используется метод put, а чтобы получить по ключу - метод get. Реализация интерфейса Map также позволяет получить наборы как ключей, так и значений. А метод entrySet() возвращает набор всех элементов в виде объектов Map.Entry<K, V>.
//Обобщенный интерфейс Map.Entry<K, V> представляет объект с ключом типа K и значением типа V и определяет следующие методы:
//•	boolean equals(Object obj): возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему
//•	K getKey(): возвращает ключ объекта отображения
//•	V getValue(): возвращает значение объекта отображения
//•	V setValue(V v): устанавливает для текущего объекта значение v
//•	int hashCode(): возвращает хеш-код данного объекта
//При переборе объектов отображения мы будем оперировать этими методами для работы с ключами и значениями объектов.

import java.util.*;

public class Task_1 {
    public static void main(String[] args) {

        Map<Integer, String> db = new HashMap<>();   //значение по умолчанию - 16
//        Map<Integer, String> db = new HashMap<>(9);   //можно сразу задать значение
//        Map<Integer, String> db = new HashMap<>(9, 1.0f);


        db.put(1, "один"); System.out.println(db);
        db.putIfAbsent(1, "ОДИН"); System.out.println(db);
        // putIfAbsent - данный метод позволяет делать проверку (если такой ключ есть, тогда ничего не будем добавлять)
        // в противном случае (без его использования) значения по данному ключу перезапишутся!!!
        db.put(1, "ОДИН"); System.out.println(db);
        db.put(2, "два"); System.out.println(db);
        db.put(3, "три"); System.out.println(db);
        db.put(31, "три один"); System.out.println(db);
        db.put(13, "один три"); System.out.println(db);
        db.put(null, "!null"); System.out.println(db);
        db.put(null, null); System.out.println(db);

//•	boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
        System.out.println("containsValue возвращает true, если коллекция содержит значение v - " + db.containsValue("один")); // true
        System.out.println("containsValue возвращает true, если коллекция содержит значение v - " + db.containsValue(1)); // false

//•	boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
        System.out.println("containsKey возвращает true, если коллекция содержит ключ k - " + db.containsKey("один")); // false
        System.out.println("containsKey возвращает true, если коллекция содержит ключ k - " + db.containsKey(1)); // true

//•	Set<K> keySet(): возвращает набор всех ключей отображения
        System.out.println("keySet возвращает набор всех ключей отображения - " + db.keySet());

//•	Collection<V> values(): возвращает набор всех значений отображения
        System.out.println("values возвращает набор всех значений отображения - " + db.values());

        // Работа с for Each:
        System.out.println("\nentrySet Перебор всех ключей и их значений:");
        for (var item : db.entrySet()) {        // перебор всех ключей и значений
            System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());
        }

    }
}